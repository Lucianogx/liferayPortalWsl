"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dropDown = _interopRequireDefault(require("@clayui/drop-down"));

var _form = require("@clayui/form");

var _icon = _interopRequireDefault(require("@clayui/icon"));

var _shared = require("@clayui/shared");

var _react = _interopRequireWildcard(require("react"));

var _tinycolor = _interopRequireDefault(require("tinycolor2"));

var _Basic = _interopRequireDefault(require("./Basic"));

var _Custom = _interopRequireDefault(require("./Custom"));

var _Editor = require("./Editor");

var _Splotch = _interopRequireDefault(require("./Splotch"));

var _util = require("./util");

var _excluded = ["active", "ariaLabels", "colors", "defaultActive", "defaultValue", "disabled", "dropDownContainerProps", "label", "name", "onActiveChange", "onChange", "onColorsChange", "onValueChange", "predefinedColors", "showHex", "showPalette", "showPredefinedColorsWithCustom", "small", "splotchTitle", "spritemap", "title", "useNative", "value"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var DEFAULT_COLORS = ['000000', '5F5F5F', '9A9A9A', 'CBCBCB', 'E1E1E1', 'FFFFFF', 'FF0D0D', 'FF8A1C', '2BA676', '006EF8', '7F26FF', 'FF21A0', 'FF5F5F', 'FFB46E', '50D2A0', '4B9BFF', 'AF78FF', 'FF73C3', 'FFB1B1', 'FFDEC0', '91E3C3', '9DC8FF', 'DFCAFF', 'FFC5E6', 'FFD9D9', 'FFF3E8', 'B1EBD5', 'C5DFFF', 'F8F2FF', 'FFEDF7'];
var BLANK_COLORS = Array(12).fill('FFFFFF');
var DEFAULT_ARIA_LABELS = {
  selectColor: 'Select a color',
  selectionIs: 'Color selection is {0}'
};

var ClayColorPicker = function ClayColorPicker(_ref) {
  var active = _ref.active,
      _ref$ariaLabels = _ref.ariaLabels,
      ariaLabels = _ref$ariaLabels === void 0 ? DEFAULT_ARIA_LABELS : _ref$ariaLabels,
      colors = _ref.colors,
      _ref$defaultActive = _ref.defaultActive,
      defaultActive = _ref$defaultActive === void 0 ? false : _ref$defaultActive,
      _ref$defaultValue = _ref.defaultValue,
      defaultValue = _ref$defaultValue === void 0 ? 'FFFFFF' : _ref$defaultValue,
      disabled = _ref.disabled,
      dropDownContainerProps = _ref.dropDownContainerProps,
      label = _ref.label,
      name = _ref.name,
      onActiveChange = _ref.onActiveChange,
      onChange = _ref.onChange,
      _onColorsChange = _ref.onColorsChange,
      onValueChange = _ref.onValueChange,
      predefinedColors = _ref.predefinedColors,
      _ref$showHex = _ref.showHex,
      showHex = _ref$showHex === void 0 ? true : _ref$showHex,
      _ref$showPalette = _ref.showPalette,
      showPalette = _ref$showPalette === void 0 ? true : _ref$showPalette,
      _ref$showPredefinedCo = _ref.showPredefinedColorsWithCustom,
      showPredefinedColorsWithCustom = _ref$showPredefinedCo === void 0 ? false : _ref$showPredefinedCo,
      small = _ref.small,
      splotchTitle = _ref.splotchTitle,
      spritemap = _ref.spritemap,
      title = _ref.title,
      _ref$useNative = _ref.useNative,
      useNative = _ref$useNative === void 0 ? false : _ref$useNative,
      value = _ref.value,
      otherProps = _objectWithoutProperties(_ref, _excluded);

  var _useInternalState = (0, _shared.useInternalState)({
    defaultName: 'defaultValue',
    defaultValue: defaultValue ? normalizeValueHex(defaultValue) : undefined,
    handleName: 'onChange',
    name: 'value',
    onChange: onChange !== null && onChange !== void 0 ? onChange : onValueChange,
    value: value
  }),
      _useInternalState2 = _slicedToArray(_useInternalState, 2),
      internalValue = _useInternalState2[0],
      setValue = _useInternalState2[1];

  var color = (0, _react.useMemo)(function () {
    return internalValue.includes('var(') ? (0, _util.getCSSVariableColor)(internalValue) : (0, _tinycolor.default)(internalValue);
  }, [internalValue]);
  var customColors = colors ? colors.concat(BLANK_COLORS).slice(0, 12) : BLANK_COLORS;

  var _useEditor = (0, _Editor.useEditor)(internalValue, color, customColors),
      _useEditor2 = _slicedToArray(_useEditor, 2),
      state = _useEditor2[0],
      dispatch = _useEditor2[1];

  var _useState = (0, _react.useState)(!showPalette),
      _useState2 = _slicedToArray(_useState, 2),
      customEditorActive = _useState2[0],
      setCustomEditorActive = _useState2[1];

  var isHex = (0, _tinycolor.default)(internalValue).getFormat() === 'hex';
  var inputColorTypeSupport = (0, _react.useMemo)(function () {
    if (typeof document !== 'undefined') {
      var input = document.createElement('input');
      input.setAttribute('type', 'color');
      return input.value !== '';
    }

    return true;
  }, []);

  if (!inputColorTypeSupport) {
    useNative = false;
  }

  var triggerElementRef = (0, _react.useRef)(null);
  var dropdownContainerRef = (0, _react.useRef)(null);
  var inputRef = (0, _react.useRef)(null);
  var valueInputRef = (0, _react.useRef)(null);
  var splotchRef = (0, _react.useRef)(null);

  var _useInternalState3 = (0, _shared.useInternalState)({
    defaultName: 'defaultActive',
    defaultValue: defaultActive,
    handleName: 'onActiveChange',
    name: 'active',
    onChange: onActiveChange,
    value: active
  }),
      _useInternalState4 = _slicedToArray(_useInternalState3, 2),
      internalActive = _useInternalState4[0],
      setInternalActive = _useInternalState4[1];

  (0, _react.useEffect)(function () {
    if (!internalActive) {
      setCustomEditorActive(false);
    }
  }, [internalActive]);
  return /*#__PURE__*/_react.default.createElement(_shared.FocusScope, {
    arrowKeysUpDown: false
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "clay-color-picker"
  }, title && /*#__PURE__*/_react.default.createElement("label", null, title), /*#__PURE__*/_react.default.createElement(_form.ClayInput.Group, {
    className: "clay-color",
    ref: triggerElementRef,
    small: small
  }, /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, {
    prepend: showHex,
    shrink: true
  }, name && /*#__PURE__*/_react.default.createElement("input", {
    name: name,
    onChange: function onChange(event) {
      return useNative ? setValue(event.target.value) : null;
    },
    ref: valueInputRef,
    style: {
      height: 0,
      position: 'absolute',
      visibility: 'hidden',
      width: 0
    },
    tabIndex: -1,
    type: useNative ? 'color' : 'text',
    value: internalValue ? "".concat(isHex ? '#' : '').concat(internalValue) : ''
  }), /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupText, null, /*#__PURE__*/_react.default.createElement(_Splotch.default, {
    "aria-label": ariaLabels.selectColor,
    className: "dropdown-toggle",
    disabled: disabled,
    onClick: function onClick() {
      {
        if (useNative && valueInputRef.current) {
          valueInputRef.current.click();
        } else {
          setInternalActive(!internalActive);

          if (!showPalette) {
            setCustomEditorActive(!customEditorActive);
          }
        }
      }
    },
    ref: splotchRef,
    title: splotchTitle,
    value: internalValue
  }))), /*#__PURE__*/_react.default.createElement(_dropDown.default.Menu, {
    active: internalActive,
    alignElementRef: triggerElementRef,
    className: "clay-color-dropdown-menu",
    containerProps: dropDownContainerProps,
    onActiveChange: setInternalActive,
    ref: dropdownContainerRef,
    triggerRef: splotchRef
  }, (!_onColorsChange || showPredefinedColorsWithCustom && !customEditorActive) && /*#__PURE__*/_react.default.createElement(_Basic.default, {
    colors: (showPredefinedColorsWithCustom ? predefinedColors : colors) || DEFAULT_COLORS,
    label: label,
    onChange: function onChange(newVal) {
      setValue(newVal);
      setInternalActive(!internalActive);

      if (splotchRef.current) {
        splotchRef.current.focus();
      }
    }
  }), _onColorsChange && /*#__PURE__*/_react.default.createElement(_Custom.default, {
    color: color,
    colors: customColors,
    editorActive: customEditorActive,
    label: label,
    onChange: function onChange(color, hex) {
      dispatch({
        hex: color.toHex(),
        hue: color.toHsv().h
      });
      setValue(hex);
    },
    onColorsChange: function onColorsChange(hex, index) {
      var newColors = _toConsumableArray(customColors);

      newColors[index] = hex;

      _onColorsChange(newColors);
    },
    onEditorActiveChange: setCustomEditorActive,
    onSplotchChange: function onSplotchChange(splotch) {
      return dispatch({
        splotch: splotch
      });
    },
    showPalette: showPalette,
    splotch: state.splotch,
    spritemap: spritemap
  }), _onColorsChange && customEditorActive && /*#__PURE__*/_react.default.createElement(_Editor.Editor, {
    color: color,
    colors: customColors,
    hex: state.hex,
    hue: state.hue,
    onChange: function onChange(color, active) {
      var hex = color.toHex();

      if (active) {
        var newColors = _toConsumableArray(customColors);

        newColors[state.splotch] = hex;

        _onColorsChange(newColors);
      } else {
        dispatch({
          splotch: undefined
        });
      }

      setValue(hex);
    },
    onColorChange: function onColorChange(color) {
      var hex = color.toHex();

      var newColors = _toConsumableArray(customColors);

      newColors[state.splotch] = hex;

      _onColorsChange(newColors);

      setValue(hex);
      dispatch({
        hex: hex
      });
    },
    onHexChange: function onHexChange(hex) {
      return dispatch({
        hex: hex
      });
    },
    onHueChange: function onHueChange(hue) {
      return dispatch({
        hue: hue
      });
    }
  })), showHex && /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, {
    append: true
  }, /*#__PURE__*/_react.default.createElement(_form.ClayInput, _extends({}, otherProps, {
    "aria-label": (0, _shared.sub)(ariaLabels.selectionIs, [internalValue]),
    disabled: disabled,
    insetBefore: true,
    onBlur: function onBlur(event) {
      var value = event.target.value;

      if (otherProps.onBlur) {
        otherProps.onBlur(event);
      }

      if (event.defaultPrevented) {
        return;
      }

      var newColor = (0, _tinycolor.default)(value);

      if (newColor.isValid()) {
        if (newColor.getFormat() === 'hex') {
          value = newColor.toHex();
        } else if (newColor.toString() !== value) {
          value = newColor.toString();
        }
      } else if (!value.includes('var(')) {
        value = '';
      }

      if (_onColorsChange && !internalActive) {
        var index = customColors.findIndex(function (color) {
          return color.toUpperCase() === value.toUpperCase();
        });
        dispatch({
          splotch: index !== -1 ? index : undefined
        });
      }

      setValue(value);
    },
    onChange: function onChange(event) {
      var value = normalizeValueHex(event.target.value);
      var color = value.includes('var(') ? (0, _util.getCSSVariableColor)(value) : (0, _tinycolor.default)(value);

      if (_onColorsChange && (color.isValid() || value.includes('var('))) {
        dispatch({
          hex: color.toHex(),
          hue: color.toHsv().h
        });

        if (internalActive) {
          var newColors = _toConsumableArray(customColors);

          newColors[state.splotch] = color.toHex();

          _onColorsChange(newColors);
        } else {
          var colorIndex = (0, _util.findColorIndex)(customColors, value.includes('var(') ? (0, _util.getCSSVariableColor)(value) : (0, _tinycolor.default)(value));

          if (colorIndex === -1) {
            dispatch({
              splotch: undefined
            });
          }
        }
      }

      setValue(value);
    },
    ref: inputRef,
    type: "text",
    value: internalValue
  })), /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupInsetItem, {
    before: true,
    tag: "label"
  }, isHex ? '#' : /*#__PURE__*/_react.default.createElement(_icon.default, {
    spritemap: spritemap,
    style: {
      width: 10
    },
    symbol: "color-picker"
  }))))));
};

function normalizeValueHex(value) {
  var isHex = (0, _tinycolor.default)(value).getFormat() === 'hex';

  if (isHex && value.indexOf('#') === 0) {
    value = value.slice(1);
  }

  return value;
}

var _default = ClayColorPicker;
exports.default = _default;