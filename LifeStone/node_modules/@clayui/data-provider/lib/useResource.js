"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useResource = exports.Resource = exports.NetworkStatus = exports.FetchPolicy = void 0;

var _provider = require("@clayui/provider");

var _shared = require("@clayui/shared");

var _react = _interopRequireWildcard(require("react"));

var _warning = _interopRequireDefault(require("warning"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var FetchPolicy;
/**
 * - Loading (1) The status is set to `loading` only when the first
 *   requisition occurs.
 * - Refetch (2) The status is set to `refetch` when a change in the variables API
 *   or refetch method is called.
 * - Polling (3) The status is set to `polling` when pollInterval is set above 0.
 * - Unused (4) When no request is happening the status will be `unused`.
 * - Error (5) When any timeout or request `error` occurs, the status will be set
 *   to error.
 */

exports.FetchPolicy = FetchPolicy;

(function (FetchPolicy) {
  FetchPolicy["CacheFirst"] = "cache-first";
  FetchPolicy["NoCache"] = "no-cache";
  FetchPolicy["CacheAndNetwork"] = "cache-and-network";
})(FetchPolicy || (exports.FetchPolicy = FetchPolicy = {}));

var NetworkStatus;
exports.NetworkStatus = NetworkStatus;

(function (NetworkStatus) {
  NetworkStatus[NetworkStatus["Error"] = 5] = "Error";
  NetworkStatus[NetworkStatus["Loading"] = 1] = "Loading";
  NetworkStatus[NetworkStatus["Polling"] = 3] = "Polling";
  NetworkStatus[NetworkStatus["Refetch"] = 2] = "Refetch";
  NetworkStatus[NetworkStatus["Unused"] = 4] = "Unused";
})(NetworkStatus || (exports.NetworkStatus = NetworkStatus = {}));

var idCounter = 0;

var useResource = function useResource(_ref) {
  var _client$current$read;

  var fetcher = _ref.fetch,
      _ref$fetchDelay = _ref.fetchDelay,
      fetchDelay = _ref$fetchDelay === void 0 ? 300 : _ref$fetchDelay,
      fetchOptions = _ref.fetchOptions,
      _ref$fetchPolicy = _ref.fetchPolicy,
      fetchPolicy = _ref$fetchPolicy === void 0 ? FetchPolicy.NoCache : _ref$fetchPolicy,
      _ref$fetchRetry = _ref.fetchRetry,
      fetchRetry = _ref$fetchRetry === void 0 ? {} : _ref$fetchRetry,
      _ref$fetchTimeout = _ref.fetchTimeout,
      fetchTimeout = _ref$fetchTimeout === void 0 ? 6000 : _ref$fetchTimeout,
      link = _ref.link,
      _ref$onNetworkStatusC = _ref.onNetworkStatusChange,
      onNetworkStatusChange = _ref$onNetworkStatusC === void 0 ? function () {} : _ref$onNetworkStatusC,
      _ref$pollInterval = _ref.pollInterval,
      pollInterval = _ref$pollInterval === void 0 ? 0 : _ref$pollInterval,
      storageMaxSize = _ref.storageMaxSize,
      _ref$suspense = _ref.suspense,
      suspense = _ref$suspense === void 0 ? false : _ref$suspense,
      _ref$variables = _ref.variables,
      variables = _ref$variables === void 0 ? null : _ref$variables;

  // We changed the cache policy when suspense is enabled so that the
  // integration with suspense and the client works better, we need
  // to store the data that was retrieved from the promise in progress
  // on the client and then get it again to fill in the hook.
  // When we throw the promise at render time, suspense invokes and resets
  // the hook states and refs every time, when realizes the promise has been
  // resolved starts the hooks lifecycle with useEffects and other states.
  if (fetchPolicy === FetchPolicy.NoCache && suspense) {
    fetchPolicy = FetchPolicy.CacheAndNetwork;
  }

  var pollingTimeoutIdRef = (0, _react.useRef)(null);
  var retryDelayTimeoutIdRef = (0, _react.useRef)(null);
  var abortController = (0, _react.useRef)(null);
  var networkStatusRef = (0, _react.useRef)();
  var pollIntervalRef = (0, _react.useRef)(pollInterval);
  var uid = (0, _react.useMemo)(function () {
    idCounter++;
    return String(idCounter);
  }, []); // A flag to identify if the first rendering happened to avoid
  // two requests.

  var firstRenderRef = (0, _react.useRef)(true);
  var firstRequestRef = (0, _react.useRef)(false);
  var shouldUseCache = fetchPolicy === FetchPolicy.CacheFirst || fetchPolicy === FetchPolicy.CacheAndNetwork;
  var identifier = (0, _react.useMemo)(function () {
    if (typeof link === 'string') {
      return (0, _util.getIdentifier)(link, variables, fetchOptions);
    }

    return uid;
  }, [link, variables, fetchOptions]);

  var _useProvider = (0, _provider.useProvider)(),
      globalClient = _useProvider.client;

  var client = (0, _react.useRef)(globalClient !== null && globalClient !== void 0 ? globalClient : new _provider.__UNSTABLE_DataClient({
    storageMaxSize: storageMaxSize
  }));
  "production" !== "production" ? (0, _warning.default)(!(suspense && typeof globalClient === 'undefined'), 'DataProvider: for the integration with Suspense to work correctly, the ClayProvider must be declared at the root of the project.') : void 0;

  var _useState = (0, _react.useState)((_client$current$read = client.current.read(identifier)) !== null && _client$current$read !== void 0 ? _client$current$read : null),
      _useState2 = _slicedToArray(_useState, 2),
      resource = _useState2[0],
      setResource = _useState2[1];

  var debouncedVariablesChange = (0, _shared.useDebounce)(variables, fetchDelay);

  var dispatchNetworkStatus = function dispatchNetworkStatus(status) {
    onNetworkStatusChange(status);
    networkStatusRef.current = status;
  };

  var cleanRetry = function cleanRetry() {
    if (retryDelayTimeoutIdRef.current) {
      clearTimeout(retryDelayTimeoutIdRef.current);
    }
  };

  var getRetryDelay = function getRetryDelay(retryAttempts) {
    var _fetchRetry$delay = fetchRetry.delay,
        delay = _fetchRetry$delay === void 0 ? {} : _fetchRetry$delay;
    var _delay$initial = delay.initial,
        initial = _delay$initial === void 0 ? 300 : _delay$initial,
        _delay$jitter = delay.jitter,
        jitter = _delay$jitter === void 0 ? true : _delay$jitter;
    var baseDelay = jitter ? initial : initial / 2;
    var value = baseDelay * Math.pow(2, retryAttempts);

    if (jitter) {
      value = Math.random() * value;
    }

    return value;
  };

  var handleFetchRetry = function handleFetchRetry(error, retryAttempts) {
    var _fetchRetry$attempts = fetchRetry.attempts,
        attempts = _fetchRetry$attempts === void 0 ? 5 : _fetchRetry$attempts;
    cleanRetry();

    if (attempts > 0 && retryAttempts < attempts) {
      var delay = getRetryDelay(retryAttempts); // eslint-disable-next-line no-console

      console.warn("DataProvider: Trying ".concat(retryAttempts + 1, " of ").concat(attempts, " will happen in ").concat(delay, "ms"));
      retryDelayTimeoutIdRef.current = setTimeout(function () {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        doFetch(retryAttempts + 1);
      }, delay);
    } else {
      if (suspense) {
        client.current.update(identifier, error);
      } else {
        dispatchNetworkStatus(NetworkStatus.Error);
      }

      "production" !== "production" ? (0, _warning.default)(false, "DataProvider: Error making the requisition ".concat(error)) : void 0;
    }
  };

  var cleanPoll = function cleanPoll() {
    return pollingTimeoutIdRef.current && clearTimeout(pollingTimeoutIdRef.current);
  };

  var setPoll = function setPoll() {
    cleanPoll();
    pollingTimeoutIdRef.current = setTimeout(function () {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      maybeFetch(NetworkStatus.Polling);
    }, pollIntervalRef.current);
  };

  var fetchOnComplete = function fetchOnComplete(result) {
    // Should clear retry interval if any of the
    // attempts are successful.
    cleanRetry();
    var data = result;
    var cursor = client.current.getCursor(identifier);

    if (networkStatusRef.current === NetworkStatus.Loading && (cursor || cursor === null) && resource !== null && resource !== undefined) {
      if (Array.isArray(result) && Array.isArray(resource)) {
        data = [].concat(_toConsumableArray(resource), _toConsumableArray(result));
      } else if (_typeof(result) === 'object' && _typeof(resource) === 'object') {
        data = _objectSpread(_objectSpread({}, resource), result);
      }
    }

    setResource(data);
    dispatchNetworkStatus(NetworkStatus.Unused);

    if (shouldUseCache) {
      client.current.update(identifier, data);
    }

    if (pollIntervalRef.current > 0) {
      setPoll();
    }

    return result;
  };

  var populateSearchParams = function populateSearchParams(uri, variables) {
    if (!variables) {
      return uri;
    }

    var keys = Object.keys(variables);
    keys.forEach(function (key) {
      return uri.searchParams.set(key, variables[key]);
    });
    return uri;
  };

  var getUrlFormat = function getUrlFormat(link, variables) {
    var uri = new URL(link);

    if (client.current.getCursor(identifier) === null) {
      "production" !== "production" ? (0, _warning.default)(uri.searchParams.toString() === '', 'DataProvider: We recommend that instead of passing parameters over the link, use the variables API. \n More details: https://clayui.com/docs/components/data-provider.html') : void 0;
    }

    if (!variables) {
      return uri.toString();
    }

    populateSearchParams(uri, variables);
    return uri.toString();
  };

  var doFetch = function doFetch() {
    var retryAttempts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    "production" !== "production" ? (0, _warning.default)(typeof link === 'string', 'DataProvider: The behavior of the `link` accepting a function has been deprecated in favor of the `fetcher` API. \n More details: https://clayui.com/docs/components/data-provider.html#data-fetching') : void 0;

    switch (_typeof(link)) {
      case 'function':
        return (0, _util.timeout)(fetchTimeout, link(populateSearchParams( // This is just a hack to be able to instantiate the URL and make
        // `populateSearchParams` reusable in `getUrlFormat` and make
        // things easier.
        new URL('http://clay.data.provider'), variables).searchParams.toString())).then(fetchOnComplete).catch(function (error) {
          return handleFetchRetry(error, retryAttempts);
        });

      case 'string':
        {
          var _client$current$getCu;

          var fn = fetcher !== null && fetcher !== void 0 ? fetcher : fetch;
          var nextCursor = undefined;

          if (abortController.current) {
            abortController.current.abort();
          }

          abortController.current = new AbortController();
          return (0, _util.timeout)(fetchTimeout, fn(getUrlFormat((_client$current$getCu = client.current.getCursor(identifier)) !== null && _client$current$getCu !== void 0 ? _client$current$getCu : link, variables), _objectSpread(_objectSpread({}, fetchOptions), {}, {
            signal: abortController.current.signal
          })), abortController.current).then(function (res) {
            if (res instanceof Response && res.ok && !res.bodyUsed) {
              return res.json();
            } else if (!(res instanceof Response) && res.items && (res.cursor || res.cursor === null)) {
              nextCursor = res.cursor;
              return res.items;
            }

            return res;
          }).then(fetchOnComplete).then(function (res) {
            if (nextCursor !== undefined) {
              client.current.setCursor(identifier, nextCursor);
            }

            return res;
          }).catch(function (error) {
            return handleFetchRetry(error, retryAttempts);
          });
        }

      default:
        return null;
    }
  };

  var maybeFetch = function maybeFetch(status) {
    var data = client.current.read(identifier);

    if (shouldUseCache && data) {
      fetchOnComplete(data); // When fetch policy is only cache-first and gets the data from
      // the cache, it should not perform a request, only when it is
      // cache-and-network.

      if (fetchPolicy === FetchPolicy.CacheFirst) {
        return false;
      }
    }

    dispatchNetworkStatus(status);
    return doFetch();
  };

  var loadMore = function loadMore() {
    if (!client.current.getCursor(identifier)) {
      return null;
    }

    dispatchNetworkStatus(NetworkStatus.Loading);
    return doFetch();
  };

  var refetch = function refetch() {
    if (!shouldUseCache) {
      // Resets the cursor
      delete client.current.cursors[identifier];
    }

    dispatchNetworkStatus(NetworkStatus.Refetch);
    doFetch();
  };

  (0, _react.useEffect)(function () {
    pollIntervalRef.current = pollInterval;

    if (pollInterval > 0) {
      setPoll();
    }
  }, [pollInterval]);
  (0, _react.useEffect)(function () {
    if (!firstRenderRef.current) {
      if (!shouldUseCache) {
        // Resets the cursor
        delete client.current.cursors[identifier];
      }

      maybeFetch(NetworkStatus.Refetch);
    }
  }, [debouncedVariablesChange]);
  (0, _react.useEffect)(function () {
    firstRenderRef.current = false;
    return function () {
      // Set to zero to prevent any unfinished requests
      // from continuing polling after umount has occurred.
      pollIntervalRef.current = 0;
      cleanPoll();
      cleanRetry();
    };
  }, []);
  var fetchingOrError = client.current.isFetching(identifier); // Makes first request if not started at render time

  if (!fetchingOrError && firstRenderRef.current) {
    var result = maybeFetch(NetworkStatus.Loading);

    if (result) {
      firstRequestRef.current = true;
      fetchingOrError = result;
      client.current.update(identifier, result);
    }
  } // Attach the promise to the instance if it is not the that started
  // the request.


  if (fetchingOrError && firstRequestRef.current === false && !suspense) {
    firstRequestRef.current = true;

    if (fetchingOrError instanceof Promise) {
      fetchingOrError.then(fetchOnComplete);
    }
  } // Integration with React.Suspense


  if (suspense && resource === null && (fetchingOrError instanceof Promise || fetchingOrError instanceof Error)) {
    // Integration with React.Suspense, throwing a throw with the promise in
    // progress at render time for Suspense to catch.
    // Integration with ErrorBoundary, when a network error happens we throw
    // an error at render time so that ErrorBoundary catches the error.
    throw fetchingOrError;
  }

  return {
    loadMore: loadMore,
    refetch: refetch,
    resource: resource
  };
}; // This is just a fake component so that react-docgen can generate the Table
// API for useResource hook.
// eslint-disable-next-line @typescript-eslint/no-unused-vars


exports.useResource = useResource;

var Resource = function Resource(props) {
  return /*#__PURE__*/_react.default.createElement("div", null);
};

exports.Resource = Resource;