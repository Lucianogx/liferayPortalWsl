"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.itemLabelFilter = exports.default = void 0;

var _autocomplete = _interopRequireDefault(require("@clayui/autocomplete"));

var _button = require("@clayui/button");

var _dropDown = _interopRequireDefault(require("@clayui/drop-down"));

var _form = require("@clayui/form");

var _icon = _interopRequireDefault(require("@clayui/icon"));

var _label2 = _interopRequireDefault(require("@clayui/label"));

var _loadingIndicator = _interopRequireDefault(require("@clayui/loading-indicator"));

var _shared = require("@clayui/shared");

var _classnames = _interopRequireDefault(require("classnames"));

var _fuzzy = _interopRequireDefault(require("fuzzy"));

var _react = _interopRequireWildcard(require("react"));

var _excluded = ["allowsCustomLabel", "alignmentByViewport", "clearAllTitle", "closeButtonAriaLabel", "defaultItems", "defaultValue", "disabled", "disabledClearAll", "hotkeysDescription", "inputName", "inputValue", "isLoading", "isValid", "items", "liveRegion", "locator", "menuRenderer", "onBlur", "onChange", "onClearAllButtonClick", "onFocus", "onItemsChange", "onKeyDown", "onPaste", "placeholder", "size", "sourceItems", "spritemap", "value"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var DELIMITER_KEYS = ['Enter', ','];

var MultiSelectMenuRenderer = function MultiSelectMenuRenderer(_ref) {
  var locator = _ref.locator,
      _ref$onItemClick = _ref.onItemClick,
      onItemClick = _ref$onItemClick === void 0 ? function () {} : _ref$onItemClick,
      sourceItems = _ref.sourceItems,
      value = _ref.value;
  return /*#__PURE__*/_react.default.createElement(_dropDown.default.ItemList, null, sourceItems.map(function (item) {
    return /*#__PURE__*/_react.default.createElement(_autocomplete.default.Item, {
      key: item[locator.value],
      match: value,
      onClick: function onClick() {
        return onItemClick(item);
      },
      value: item[locator.label]
    });
  }));
};

var KeysNavigation = [_shared.Keys.Left, _shared.Keys.Right, _shared.Keys.Up, _shared.Keys.Down];
var KeysSides = [_shared.Keys.Left, _shared.Keys.Right];
var counterUid = 0;

var ClayMultiSelect = /*#__PURE__*/_react.default.forwardRef(function (_ref2, ref) {
  var _ref2$allowsCustomLab = _ref2.allowsCustomLabel,
      allowsCustomLabel = _ref2$allowsCustomLab === void 0 ? true : _ref2$allowsCustomLab,
      _ref2$alignmentByView = _ref2.alignmentByViewport,
      alignmentByViewport = _ref2$alignmentByView === void 0 ? false : _ref2$alignmentByView,
      _ref2$clearAllTitle = _ref2.clearAllTitle,
      clearAllTitle = _ref2$clearAllTitle === void 0 ? 'Clear All' : _ref2$clearAllTitle,
      _ref2$closeButtonAria = _ref2.closeButtonAriaLabel,
      closeButtonAriaLabel = _ref2$closeButtonAria === void 0 ? 'Remove {0}' : _ref2$closeButtonAria,
      _ref2$defaultItems = _ref2.defaultItems,
      defaultItems = _ref2$defaultItems === void 0 ? [] : _ref2$defaultItems,
      _ref2$defaultValue = _ref2.defaultValue,
      defaultValue = _ref2$defaultValue === void 0 ? '' : _ref2$defaultValue,
      disabled = _ref2.disabled,
      disabledClearAll = _ref2.disabledClearAll,
      _ref2$hotkeysDescript = _ref2.hotkeysDescription,
      hotkeysDescription = _ref2$hotkeysDescript === void 0 ? 'Press backspace to delete the current row.' : _ref2$hotkeysDescript,
      inputName = _ref2.inputName,
      inputValue = _ref2.inputValue,
      _ref2$isLoading = _ref2.isLoading,
      isLoading = _ref2$isLoading === void 0 ? false : _ref2$isLoading,
      _ref2$isValid = _ref2.isValid,
      isValid = _ref2$isValid === void 0 ? true : _ref2$isValid,
      items = _ref2.items,
      _ref2$liveRegion = _ref2.liveRegion,
      liveRegion = _ref2$liveRegion === void 0 ? {
    added: 'Label {0} added to the list',
    removed: 'Label {0} removed to the list'
  } : _ref2$liveRegion,
      _ref2$locator = _ref2.locator,
      locator = _ref2$locator === void 0 ? {
    id: 'key',
    label: 'label',
    value: 'value'
  } : _ref2$locator,
      _ref2$menuRenderer = _ref2.menuRenderer,
      MenuRenderer = _ref2$menuRenderer === void 0 ? MultiSelectMenuRenderer : _ref2$menuRenderer,
      _ref2$onBlur = _ref2.onBlur,
      _onBlur = _ref2$onBlur === void 0 ? _shared.noop : _ref2$onBlur,
      onChange = _ref2.onChange,
      onClearAllButtonClick = _ref2.onClearAllButtonClick,
      _ref2$onFocus = _ref2.onFocus,
      _onFocus = _ref2$onFocus === void 0 ? _shared.noop : _ref2$onFocus,
      onItemsChange = _ref2.onItemsChange,
      _ref2$onKeyDown = _ref2.onKeyDown,
      onKeyDown = _ref2$onKeyDown === void 0 ? _shared.noop : _ref2$onKeyDown,
      _ref2$onPaste = _ref2.onPaste,
      onPaste = _ref2$onPaste === void 0 ? _shared.noop : _ref2$onPaste,
      placeholder = _ref2.placeholder,
      size = _ref2.size,
      _ref2$sourceItems = _ref2.sourceItems,
      sourceItems = _ref2$sourceItems === void 0 ? [] : _ref2$sourceItems,
      spritemap = _ref2.spritemap,
      value = _ref2.value,
      otherProps = _objectWithoutProperties(_ref2, _excluded);

  var containerRef = (0, _react.useRef)(null);
  var inputRef = (0, _react.useRef)(null);
  var lastItemRef = (0, _react.useRef)(null);
  var lastChangesRef = (0, _react.useRef)(null);
  var labelsRef = (0, _react.useRef)(null);

  var _useState = (0, _react.useState)(null),
      _useState2 = _slicedToArray(_useState, 2),
      lastFocusedItem = _useState2[0],
      setLastFocusedItem = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = _slicedToArray(_useState3, 2),
      active = _useState4[0],
      setActive = _useState4[1];

  var _useState5 = (0, _react.useState)(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isFocused = _useState6[0],
      setIsFocused = _useState6[1];

  var _useInternalState = (0, _shared.useInternalState)({
    defaultName: 'defaultItems',
    defaultValue: defaultItems,
    handleName: 'onItemsChange',
    name: 'items',
    onChange: onItemsChange,
    value: items
  }),
      _useInternalState2 = _slicedToArray(_useInternalState, 2),
      internalItems = _useInternalState2[0],
      setItems = _useInternalState2[1];

  var _useInternalState3 = (0, _shared.useInternalState)({
    defaultName: 'defaultValue',
    defaultValue: defaultValue,
    handleName: 'onChange',
    name: 'value',
    onChange: onChange,
    value: value !== null && value !== void 0 ? value : inputValue
  }),
      _useInternalState4 = _slicedToArray(_useInternalState3, 2),
      internalValue = _useInternalState4[0],
      setValue = _useInternalState4[1];

  (0, _react.useEffect)(function () {
    if (isFocused) {
      setActive(!!internalValue && sourceItems.length !== 0);
    }
  }, [internalValue, isFocused, sourceItems]);
  var inputElementRef = ref || inputRef;

  var setNewValue = function setNewValue(newVal) {
    setItems([].concat(_toConsumableArray(internalItems), [newVal]));
    setValue('');
  };

  var getSourceItemByLabel = function getSourceItemByLabel(label) {
    return sourceItems.find(function (item) {
      return item[locator.label] === label;
    });
  };

  var getNewItem = function getNewItem(value) {
    var _ref3;

    counterUid++;
    return getSourceItemByLabel(value) || (_ref3 = {}, _defineProperty(_ref3, locator.label, value), _defineProperty(_ref3, locator.value, value), _defineProperty(_ref3, "key", "key_".concat(counterUid)), _ref3);
  };

  var handleKeyDown = function handleKeyDown(event) {
    onKeyDown(event);

    if (event.defaultPrevented) {
      return;
    }

    var key = event.key;

    if (key === _shared.Keys.Backspace && !internalValue) {
      event.preventDefault();
    }

    if (allowsCustomLabel && internalValue.trim() && DELIMITER_KEYS.includes(key)) {
      event.preventDefault();
      lastChangesRef.current = {
        action: 'added',
        label: internalValue
      };
      setNewValue(getNewItem(internalValue));
    } else if (!internalValue && key === _shared.Keys.Backspace && inputElementRef.current && lastItemRef.current) {
      inputElementRef.current.blur();
      lastItemRef.current.focus();
    }
  };

  var handlePaste = function handlePaste(event) {
    onPaste(event);

    if (event.defaultPrevented) {
      return;
    }

    var pastedText = event.clipboardData.getData('Text');
    var pastedItems = pastedText.split(',').map(function (itemLabel) {
      return getNewItem(itemLabel.trim());
    }).filter(Boolean);

    if (allowsCustomLabel && pastedItems.length > 0) {
      event.preventDefault();
      setItems([].concat(_toConsumableArray(internalItems), _toConsumableArray(pastedItems)));
    }
  };

  var onRemove = (0, _react.useCallback)(function (label, index) {
    if (labelsRef.current) {
      var focusableElements = Array.from(labelsRef.current.querySelectorAll('button'));
      var activeElement = document.activeElement.tagName === 'SPAN' ? document.activeElement.querySelector('button') : document.activeElement;
      var position = focusableElements.indexOf(activeElement);
      var closeElement = focusableElements[focusableElements.length - 1 > position ? position + 1 : position - 1];

      if (closeElement) {
        closeElement.focus();
        setLastFocusedItem(closeElement.getAttribute('id'));
      } else {
        var _inputElementRef$curr;

        (_inputElementRef$curr = inputElementRef.current) === null || _inputElementRef$curr === void 0 ? void 0 : _inputElementRef$curr.focus();
        setLastFocusedItem(null);
      }
    }

    lastChangesRef.current = {
      action: 'removed',
      label: label
    };
    setItems(internalItems.filter(function (_, itemIndex) {
      return itemIndex !== index;
    }));
  }, [internalItems]);

  var _useState7 = (0, _react.useState)(null),
      _useState8 = _slicedToArray(_useState7, 2),
      isLabelFocused = _useState8[0],
      setIsLabelFocused = _useState8[1];

  var labelId = (0, _shared.useId)();
  var ariaDescriptionId = (0, _shared.useId)();
  return /*#__PURE__*/_react.default.createElement(_shared.FocusScope, {
    arrowKeysUpDown: false
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)('form-control form-control-tag-group input-group', _defineProperty({
      focus: isFocused && isValid
    }, "form-control-tag-group-".concat(size), size)),
    ref: containerRef
  }, /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, null, /*#__PURE__*/_react.default.createElement(_form.ClayInput.Group, null, /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, {
    "aria-labelledby": otherProps['aria-labelledby'],
    className: "d-contents",
    onFocus: function onFocus(event) {
      return setLastFocusedItem(event.target.getAttribute('id'));
    },
    onKeyDown: function onKeyDown(event) {
      if (KeysNavigation.includes(event.key)) {
        // Query labels and buttons to exclude the label that are
        // focusable the navigation order depends on which orientation
        // the navigation is happen.
        // - Left and Right. Query all elements.
        // - Up and Down. Query for elements of the same type as the
        //   last focused element.
        var focusableElements = Array.from(event.currentTarget.querySelectorAll(KeysSides.includes(event.key) ? '[role=gridcell][tabindex], button' : lastFocusedItem !== null && lastFocusedItem !== void 0 && lastFocusedItem.includes('span') ? '[role=gridcell][tabindex]' : 'button'));
        var position = focusableElements.indexOf(document.activeElement);
        var key = KeysSides.includes(event.key) ? _shared.Keys.Left : _shared.Keys.Up;
        var label = focusableElements[event.key === key ? position - 1 : position + 1];

        if (label) {
          setLastFocusedItem(label.getAttribute('id'));
          label.focus();
        }
      }

      if (event.key === _shared.Keys.Home || event.key === _shared.Keys.End) {
        var isLabel = lastFocusedItem.includes('span');

        if (isLabel && event.key === _shared.Keys.Home || !isLabel && event.key === _shared.Keys.End) {
          return;
        }

        var _label = event.currentTarget.querySelector("[id=".concat(lastFocusedItem === null || lastFocusedItem === void 0 ? void 0 : lastFocusedItem.replace(isLabel ? 'span' : 'close', event.key === _shared.Keys.Home ? 'span' : 'close'), "]"));

        if (_label) {
          setLastFocusedItem(_label.getAttribute('id'));

          _label.focus();
        }
      }
    },
    prepend: true,
    ref: function ref(_ref6) {
      labelsRef.current = _ref6;
    },
    role: "grid",
    shrink: true
  }, internalItems.map(function (item, i) {
    var _item;

    var uid = (_item = item[locator.id]) !== null && _item !== void 0 ? _item : item[locator.value];
    var id = "".concat(labelId, "-label-").concat(uid, "-span");
    var closeId = "".concat(labelId, "-label-").concat(uid, "-close");
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
      key: id
    }, /*#__PURE__*/_react.default.createElement(_label2.default, {
      className: isLabelFocused === id ? 'focus' : undefined,
      onKeyDown: function onKeyDown(_ref4) {
        var key = _ref4.key;

        if (key === _shared.Keys.Backspace) {
          onRemove(item[locator.label], i);
        }
      },
      role: "row",
      spritemap: spritemap,
      tabIndex: -1,
      withClose: false
    }, /*#__PURE__*/_react.default.createElement(_label2.default.ItemExpand, {
      "aria-describedby": ariaDescriptionId,
      id: id,
      onBlur: function onBlur() {
        return setIsLabelFocused(null);
      },
      onFocus: function onFocus() {
        return setIsLabelFocused(id);
      },
      role: "gridcell",
      style: {
        outline: 'none'
      },
      tabIndex: lastFocusedItem === null && i === 0 || lastFocusedItem === id ? 0 : -1
    }, item[locator.label]), /*#__PURE__*/_react.default.createElement(_label2.default.ItemAfter, {
      role: "gridcell"
    }, /*#__PURE__*/_react.default.createElement("button", {
      "aria-label": (0, _shared.sub)(closeButtonAriaLabel, [item[locator.label]]),
      className: "close",
      disabled: disabled,
      id: closeId,
      onClick: function onClick() {
        return onRemove(item[locator.label], i);
      },
      ref: function ref(_ref5) {
        if (i === internalItems.length - 1) {
          lastItemRef.current = _ref5;
        }
      },
      tabIndex: lastFocusedItem === closeId ? 0 : -1,
      type: "button"
    }, /*#__PURE__*/_react.default.createElement(_icon.default, {
      spritemap: spritemap,
      symbol: "times-small"
    })))), inputName && /*#__PURE__*/_react.default.createElement("input", {
      name: inputName,
      type: "hidden",
      value: item[locator.value]
    }));
  })), /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, {
    prepend: true
  }, /*#__PURE__*/_react.default.createElement("input", _extends({}, otherProps, {
    className: "form-control-inset",
    disabled: disabled,
    onBlur: function onBlur(event) {
      _onBlur(event);

      setIsFocused(false);
    },
    onChange: function onChange(event) {
      var value = event.target.value;
      setValue(allowsCustomLabel ? value.replace(',', '') : value);
    },
    onFocus: function onFocus(event) {
      _onFocus(event);

      setIsFocused(true);
    },
    onKeyDown: handleKeyDown,
    onPaste: handlePaste,
    placeholder: internalItems.length ? undefined : placeholder,
    ref: inputElementRef,
    type: "text",
    value: internalValue
  }))))), isLoading && /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, {
    shrink: true
  }, /*#__PURE__*/_react.default.createElement(_loadingIndicator.default, {
    small: true
  })), !disabled && !disabledClearAll && (internalValue || internalItems.length > 0) && /*#__PURE__*/_react.default.createElement(_form.ClayInput.GroupItem, {
    shrink: true
  }, /*#__PURE__*/_react.default.createElement(_button.ClayButtonWithIcon, {
    "aria-label": clearAllTitle,
    borderless: true,
    className: "component-action",
    displayType: "secondary",
    onClick: function onClick() {
      if (onClearAllButtonClick) {
        onClearAllButtonClick();
      } else {
        setItems([]);
        setValue('');
      }

      if (inputElementRef.current) {
        inputElementRef.current.focus();
      }
    },
    outline: true,
    spritemap: spritemap,
    symbol: "times-circle",
    title: clearAllTitle
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "sr-only"
  }, /*#__PURE__*/_react.default.createElement("span", {
    id: ariaDescriptionId
  }, hotkeysDescription), /*#__PURE__*/_react.default.createElement("span", {
    "aria-live": "polite",
    "aria-relevant": "text"
  }, lastChangesRef.current ? (0, _shared.sub)(liveRegion[lastChangesRef.current.action], [lastChangesRef.current.label]) : null)), sourceItems.length > 0 && /*#__PURE__*/_react.default.createElement(_autocomplete.default.DropDown, {
    active: active,
    alignElementRef: containerRef,
    alignmentByViewport: alignmentByViewport,
    onSetActive: setActive
  }, /*#__PURE__*/_react.default.createElement(MenuRenderer, {
    inputValue: internalValue,
    locator: locator,
    onItemClick: function onItemClick(item) {
      setNewValue(item);

      if (inputElementRef.current) {
        inputElementRef.current.focus();
      }
    },
    sourceItems: sourceItems,
    value: internalValue
  }))));
});

ClayMultiSelect.displayName = 'ClayMultiSelect';
/**
 * Utility used for filtering an array of items based off the locator which
 * is set to `label` by default.
 */

var itemLabelFilter = function itemLabelFilter(items, value) {
  var locator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';
  return items.filter(function (item) {
    return _fuzzy.default.match(value, item[locator]);
  });
};

exports.itemLabelFilter = itemLabelFilter;
var _default = ClayMultiSelect;
exports.default = _default;