"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useClosestTitle = useClosestTitle;

var _react = require("react");

/**
 * SPDX-FileCopyrightText: Â© 2019 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: BSD-3-Clause
 */
function matches(element, selectorString) {
  if (element.matches) {
    return element.matches(selectorString);
  } else if (element.msMatchesSelector) {
    return element.msMatchesSelector(selectorString);
  } else if (element.webkitMatchesSelector) {
    return element.webkitMatchesSelector(selectorString);
  } else {
    return false;
  }
}

function closestAncestor(node, s) {
  var element = node;
  var ancestor = node;

  if (!document.documentElement.contains(element)) {
    return null;
  }

  do {
    if (matches(ancestor, s)) {
      return ancestor;
    }

    ancestor = ancestor.parentElement;
  } while (ancestor !== null);

  return null;
}

function useClosestTitle(props) {
  var targetRef = (0, _react.useRef)(null);
  var titleNodeRef = (0, _react.useRef)(null);
  var saveTitle = (0, _react.useCallback)(function (element) {
    var title = element.getAttribute('title');

    if (title) {
      element.setAttribute('data-restore-title', title);
      element.removeAttribute('title');
    } else if (element.tagName === 'svg') {
      var titleTag = element.querySelector('title');

      if (titleTag) {
        element.setAttribute('data-restore-title', titleTag.innerHTML);
        titleTag.remove();
      }
    }
  }, []);
  var restoreTitle = (0, _react.useCallback)(function () {
    var element = titleNodeRef.current;

    if (element) {
      var title = element.getAttribute('data-restore-title');

      if (title) {
        if (element.tagName === 'svg') {
          var titleTag = document.createElement('title');
          titleTag.innerHTML = title;
          element.appendChild(titleTag);
        } else {
          element.setAttribute('title', title);
        }

        element.removeAttribute('data-restore-title');
      }

      titleNodeRef.current = null;
    }
  }, []);
  var onClick = (0, _react.useCallback)(function (event) {
    props.onClick(); // eslint-disable-next-line @typescript-eslint/no-use-before-define

    onHide(event);
  }, []);
  var onHide = (0, _react.useCallback)(function (event) {
    var _props$tooltipRef$cur, _targetRef$current;

    if (event && ((_props$tooltipRef$cur = props.tooltipRef.current) !== null && _props$tooltipRef$cur !== void 0 && _props$tooltipRef$cur.contains(event.relatedTarget) || (_targetRef$current = targetRef.current) !== null && _targetRef$current !== void 0 && _targetRef$current.contains(event.relatedTarget))) {
      return null;
    }

    props.onHide();
    restoreTitle();

    if (targetRef.current) {
      targetRef.current.removeEventListener('click', onClick);
      targetRef.current = null;
    }
  }, []);
  var getProps = (0, _react.useCallback)(function (event, hideBrowserTitle) {
    if (targetRef.current) {
      props.onClick();

      if (onHide(event) === null) {
        return;
      }
    }

    var target = event.target;
    var hasTitle = target && (target.hasAttribute('[title]') || target.hasAttribute('[data-title]'));
    var node = hasTitle ? target : closestAncestor(target, '[title], [data-title]');

    if (node) {
      targetRef.current = target;
      target.addEventListener('click', onClick);
      var title = node.getAttribute('title') || node.getAttribute('data-title') || '';
      titleNodeRef.current = node;

      if (hideBrowserTitle) {
        saveTitle(node);
      }

      return {
        align: node.getAttribute('data-tooltip-align'),
        delay: node.getAttribute('data-tooltip-delay'),
        floating: Boolean(node.getAttribute('data-tooltip-floating')),
        setAsHTML: !!node.getAttribute('data-title-set-as-html'),
        title: title
      };
    }
  }, []);
  return {
    getProps: getProps,
    onHide: onHide,
    target: targetRef,
    titleNode: titleNodeRef
  };
}