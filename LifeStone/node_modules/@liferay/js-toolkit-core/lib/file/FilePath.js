"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
class FilePath {
    constructor(nativePath, { posix = false } = {}) {
        if (posix && !FilePath.nativeIsPosix) {
            nativePath = nativePath.replace(/\//g, '\\');
        }
        this._nativePath = nativePath;
        if (FilePath.nativeIsPosix) {
            this._posixPath = nativePath;
            this._windowsPath = nativePath.replace(/\//g, '\\');
        }
        else {
            this._posixPath = nativePath.replace(/\\/g, '/');
            this._windowsPath = nativePath;
        }
    }
    static coerce(anyPath) {
        return typeof anyPath === 'string' ? new FilePath(anyPath) : anyPath;
    }
    static get sep() {
        return FilePath.nativeIsPosix ? '/' : '\\';
    }
    toString() {
        return this.asNative;
    }
    get asNative() {
        return this._nativePath;
    }
    get asPosix() {
        return this._posixPath;
    }
    get asWindows() {
        return this._windowsPath;
    }
    basename() {
        return new FilePath(path_1.default.basename(this.asNative));
    }
    dirname() {
        return new FilePath(path_1.default.dirname(this.asNative));
    }
    is(anyPath) {
        if (typeof anyPath === 'string') {
            anyPath = new FilePath(anyPath);
        }
        return anyPath.resolve().asNative === this.resolve().asNative;
    }
    isAbsolute() {
        return path_1.default.isAbsolute(this.toString());
    }
    isRelative() {
        return !this.isAbsolute();
    }
    join(...anyPathFragments) {
        const join = FilePath.nativeIsPosix ? path_1.default.posix.join : path_1.default.win32.join;
        return new FilePath(join(this.toString(), ...anyPathFragments.map((nativePathFragment) => nativePathFragment.toString())));
    }
    normalize() {
        return new FilePath(path_1.default.normalize(this.asNative));
    }
    relative(anyPath) {
        return new FilePath(path_1.default.relative(this.asNative, anyPath.toString()));
    }
    resolve() {
        const resolvedPath = path_1.default.resolve(this.asNative);
        if (resolvedPath === this.asNative) {
            return this;
        }
        return new FilePath(resolvedPath);
    }
    /**
     * Convert a relative path to a dot relative file path, i.e., convert '' to
     * '.', or 'path/to/folder' to './path/to/folder' and leave
     * '../path/to/folder' untouched.
     *
     * This method is primarily intended to convert file paths to local Node
     * module names which, when required, must begin by './' or '../' to make
     * Node treat them like locals.
     *
     * Other than that it is quite possible that it doesn't have a real use when
     * dealing with the filesystem alone.
     */
    toDotRelative() {
        if (this.isAbsolute()) {
            throw new Error('Cannot convert absolute path to dot leading local path');
        }
        // Get a path like '.', '../path/to/something'  or 'path/to/something'
        let normalizedThisPath = path_1.default.normalize(this.asNative);
        if (!normalizedThisPath.startsWith('.')) {
            normalizedThisPath = `.${FilePath.sep}${normalizedThisPath}`;
        }
        return new FilePath(normalizedThisPath);
    }
}
exports.default = FilePath;
FilePath.nativeIsPosix = path_1.default.sep === '/';
