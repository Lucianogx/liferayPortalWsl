"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevel = void 0;
const dot_prop_1 = __importDefault(require("dot-prop"));
const format_1 = require("../../format");
/** Valid log levels for console and report */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["off"] = 0] = "off";
    LogLevel[LogLevel["error"] = 1] = "error";
    LogLevel[LogLevel["warn"] = 2] = "warn";
    LogLevel[LogLevel["info"] = 3] = "info";
    LogLevel[LogLevel["debug"] = 4] = "debug";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Reflects miscellaneous project configuration values.
 */
class Misc {
    /**
     *
     * @param project
     */
    constructor(project) {
        this._project = project;
    }
    /**
     * Whether or not to dump detailed information about what the tool is doing
     */
    get logLevel() {
        if (this._logLevel === undefined) {
            const { configuration } = this._project;
            let logLevel = dot_prop_1.default.get(configuration, 'log-level', LogLevel[LogLevel.warn]);
            if (LogLevel[logLevel] === undefined) {
                (0, format_1.print)((0, format_1.warn) `Configuration value {log-level} has invalid value: it will be ignored`);
                logLevel = LogLevel[LogLevel.warn];
            }
            this._logLevel = LogLevel[logLevel];
        }
        return this._logLevel;
    }
    /**
     * Get maximum number of files to process in parallel in any parallelizable
     * operation.
     */
    get maxParallelFiles() {
        if (this._maxParallelFiles === undefined) {
            const { configuration } = this._project;
            // Default values for "ulimit -n" vary across different OSes. Some
            //
            // values I have found are:
            //   - Apparently Mac OS X limit is 256 but usually people increase it
            //   - Fedora: 1024
            //   - Windows: there's no ulimit, but MSVCRT.DLL has a 2048 limit
            //
            // Given this mess and the impossibility of retrieving the limit from
            // Node, I'm giving this a default value of 128 because it looks like it
            // doesn't impact performance and should be low enough to make it work
            // in all OSes.
            let maxParallelFiles = dot_prop_1.default.get(configuration, 'max-parallel-files', '128');
            if (parseInt(maxParallelFiles, 10) === Number.NaN) {
                (0, format_1.print)((0, format_1.warn) `Configuration value {max-parallel-files} has invalid value: it will be ignored`);
                maxParallelFiles = '128';
            }
            this._maxParallelFiles = parseInt(maxParallelFiles, 10);
        }
        return this._maxParallelFiles;
    }
    /**
     * Get the path to the report file or undefined if no report is configured.
     */
    get reportFile() {
        if (this._reportFile === undefined) {
            const { _project } = this;
            const { configuration } = _project;
            const dumpReport = dot_prop_1.default.get(configuration, 'dump-report', false);
            this._reportFile = dumpReport
                ? _project.dir.join('liferay-npm-bundler-report.html')
                : undefined;
        }
        return this._reportFile;
    }
    /**
     * Get report log level
     */
    get reportLevel() {
        if (this._reportLevel === undefined) {
            const { _project } = this;
            const { configuration } = _project;
            let dumpReport = dot_prop_1.default.get(configuration, 'dump-report', false);
            if (typeof dumpReport === 'boolean') {
                if (dumpReport) {
                    dumpReport = LogLevel[LogLevel.info];
                }
                else {
                    dumpReport = LogLevel[LogLevel.off];
                }
            }
            else if (LogLevel[dumpReport] === undefined) {
                (0, format_1.print)((0, format_1.warn) `Configuration value {dump-report} has invalid value: it will be ignored`);
                dumpReport = LogLevel[LogLevel.off];
            }
            this._reportLevel = LogLevel[dumpReport];
        }
        return this._reportLevel;
    }
}
exports.default = Misc;
