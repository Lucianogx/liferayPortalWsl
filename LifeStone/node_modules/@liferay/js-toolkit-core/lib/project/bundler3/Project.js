"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = __importDefault(require("child_process"));
const dot_prop_1 = __importDefault(require("dot-prop"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
const resolve_1 = __importDefault(require("resolve"));
const FilePath_1 = __importDefault(require("../../file/FilePath"));
const format_1 = require("../../format");
const modules_1 = require("../../node/modules");
const Adapt_1 = __importDefault(require("./Adapt"));
const Jar_1 = __importDefault(require("./Jar"));
const Localization_1 = __importDefault(require("./Localization"));
const Misc_1 = __importDefault(require("./Misc"));
const Probe_1 = __importDefault(require("./Probe"));
/**
 * Describes a standard JS Toolkit project.
 */
class Project {
    /**
     * @param projectDirPath project's path in native format
     */
    constructor(projectDirPath) {
        this.loadFrom(projectDirPath);
    }
    /**
     * Get absolute path to project's directory.
     */
    get dir() {
        return this._projectDir;
    }
    /** Get absolute path to output directory */
    get outputDir() {
        if (this._outputDir === undefined) {
            this._outputDir = this.dir.join(new FilePath_1.default(dot_prop_1.default.get(this._configuration, 'output', this.adapt.supported ? './build.liferay' : './build'), { posix: true }));
        }
        return this._outputDir;
    }
    /** Get absolute path to source directory */
    get sourceDir() {
        if (this._sourceDir === undefined) {
            this._sourceDir = this.dir.join(new FilePath_1.default(dot_prop_1.default.get(this._configuration, 'source', '.'), {
                posix: true,
            }));
        }
        return this._sourceDir;
    }
    /**
     * Get absolute path to directory where work files must be placed.
     *
     * @remarks
     * Work files are files that can be cached between different builds to speed
     * the process or simply because they can help in debugging a failed build.
     *
     * @return the work dir or undefined if not configured
     */
    get workDir() {
        if (this._workDir === undefined) {
            this._workDir = this.dir.join(new FilePath_1.default(dot_prop_1.default.get(this._configuration, 'workdir', './work'), { posix: true }));
        }
        return this._workDir;
    }
    /**
     * Get module paths	to export to the outside world making them available
     * through the AMD loader.
     *
     * @remarks
     * Note that the usual CommonJS syntax is used to differentiate local
     * modules from dependency (node_modules) modules.
     *
     * For example:
     *
     * - Local module: './src/my-api'
     * - Dependency module: 'lodash/trimEnd'
     */
    get exports() {
        if (this._exports === undefined) {
            this._exports = dot_prop_1.default.get(this._configuration, 'exports', {});
            // Export package.json's main entry (if present) automatically
            if (!this._exports['main']) {
                let main = this._pkgJson.main;
                if (main) {
                    if (main.startsWith('/')) {
                        main = `.${main}`;
                    }
                    else if (!main.startsWith('.')) {
                        main = `./${main}`;
                    }
                    this._exports['main'] = main;
                }
                else if (fs_1.default.existsSync(this.sourceDir.join('index.js').asNative)) {
                    this._exports['main'] = './index.js';
                }
            }
        }
        return this._exports;
    }
    get imports() {
        if (this._imports === undefined) {
            this._imports = {};
            const imports = dot_prop_1.default.get(this._configuration, 'imports', {});
            Object.entries(imports).forEach(([provider, config]) => {
                Object.entries(config).forEach(([pkgName, version]) => {
                    if (pkgName === '/') {
                        pkgName = provider;
                    }
                    this._imports[pkgName] = {
                        provider,
                        version,
                    };
                });
            }, {});
        }
        return this._imports;
    }
    /**
     * Get user's webpack configuration.
     */
    get webpackConfiguration() {
        if (this._webpackConfiguration === undefined) {
            this._webpackConfiguration = dot_prop_1.default.get(this._configuration, 'webpack', {});
        }
        return this._webpackConfiguration;
    }
    /**
     * Get directories inside the project containing source files starting with
     * `./` (so that they can be safely path.joined)
     */
    get sources() {
        if (this._sources === undefined) {
            this._sources = dot_prop_1.default
                .get(this._configuration, 'sources', [])
                .map((source) => source.startsWith('./') ? source : `./${source}`)
                .map((source) => new FilePath_1.default(source, { posix: true }));
        }
        return this._sources;
    }
    /**
     * Get global plugins configuration.
     */
    get globalConfig() {
        const { _configuration } = this;
        return dot_prop_1.default.get(_configuration, 'config', {});
    }
    /**
     * Get project's parsed liferay-npm-bundler.config.js file
     */
    get configuration() {
        return this._configuration;
    }
    /**
     * Get project's parsed package.json file
     */
    get pkgJson() {
        return this._pkgJson;
    }
    /**
     * Return the package manager that the project is using or null if it cannot
     * be inferred.
     */
    get pkgManager() {
        if (this._pkgManager === undefined) {
            let yarnLockPresent = fs_1.default.existsSync(this._projectDir.join('yarn.lock').asNative);
            let pkgLockPresent = fs_1.default.existsSync(this._projectDir.join('package-lock.json').asNative);
            // If both present act as if none was present
            if (yarnLockPresent && pkgLockPresent) {
                yarnLockPresent = pkgLockPresent = false;
            }
            if (yarnLockPresent) {
                this._pkgManager = 'yarn';
            }
            else if (pkgLockPresent) {
                this._pkgManager = 'npm';
            }
            else {
                // If no file is found autodetect command availability
                let yarnPresent = child_process_1.default.spawnSync('yarn', ['--version'], {
                    shell: true,
                }).error === undefined;
                let npmPresent = child_process_1.default.spawnSync('npm', ['--version'], {
                    shell: true,
                }).error === undefined;
                // If both present act as if none was present
                if (yarnPresent && npmPresent) {
                    yarnPresent = npmPresent = false;
                }
                if (yarnPresent) {
                    this._pkgManager = 'yarn';
                }
                else if (npmPresent) {
                    this._pkgManager = 'npm';
                }
            }
            // If nothing detected store null
            if (this._pkgManager === undefined) {
                this._pkgManager = null;
            }
        }
        return this._pkgManager;
    }
    /**
     * Get all available information about versions of plugins and presets used
     * for the build.
     * @return a Map where keys are package names
     */
    get versionsInfo() {
        if (this._versionsInfo === undefined) {
            const map = new Map();
            const putInMap = (packageName) => {
                const pkgJsonPath = this.resolve(`${packageName}/package.json`);
                // eslint-disable-next-line @typescript-eslint/no-var-requires, @liferay/no-dynamic-require
                const pkgJson = require(pkgJsonPath);
                map.set(pkgJson.name, {
                    path: path_1.default.relative(this.dir.asNative, path_1.default.dirname(pkgJsonPath)),
                    version: pkgJson.version,
                });
            };
            // Get bundler and me versions
            putInMap('@liferay/npm-bundler');
            putInMap(path_1.default.join(__dirname, '../../..'));
            // Get preset version
            const { _configuration } = this;
            const preset = _configuration['preset'];
            if (preset) {
                putInMap((0, modules_1.splitModuleName)(preset).pkgName);
            }
            this._versionsInfo = map;
        }
        return this._versionsInfo;
    }
    /**
     * Reload the whole project from given directory. Especially useful for
     * tests.
     * @param projectPath
     * project's path in native format (whether absolute or relative to cwd)
     * @param configFilePath
     * optional path to configuration file (relative to `projectPath` if not
     * given as an absolute path)
     */
    loadFrom(projectPath, configFilePath = 'liferay-npm-bundler.config.js') {
        // First reset everything
        this._configFile = undefined;
        this._configuration = undefined;
        this._outputDir = undefined;
        this._pkgJson = undefined;
        this._pkgManager = undefined;
        this._projectDir = undefined;
        this._sources = undefined;
        this._sourceDir = undefined;
        this._workDir = undefined;
        // Set significant directories
        this._projectDir = new FilePath_1.default(path_1.default.resolve(projectPath));
        this._configFile = new FilePath_1.default(path_1.default.isAbsolute(configFilePath)
            ? configFilePath
            : path_1.default.resolve(path_1.default.join(projectPath, configFilePath)));
        // Load configuration files
        this._loadPkgJson();
        this._loadConfiguration();
        // Initialize subdomains
        this.adapt = new Adapt_1.default(this);
        this.jar = new Jar_1.default(this);
        this.l10n = new Localization_1.default(this);
        this.misc = new Misc_1.default(this);
        this.probe = new Probe_1.default(this);
    }
    /**
     * Requires a module in the context of the project (as opposed to the
     * context of the calling package which would just use a normal `require()`
     * call).
     * @param moduleName
     */
    require(moduleName) {
        // eslint-disable-next-line @liferay/no-dynamic-require
        return require(this.resolve(moduleName));
    }
    /**
     * Resolves a module in the context of the project (as opposed to the
     * context of the calling package which would just use a normal
     * `require.resolve()` call).
     * @param moduleName
     */
    resolve(moduleName) {
        return resolve_1.default.sync(moduleName, {
            basedir: this.dir.asNative,
        });
    }
    /**
     * Set program arguments so that some of them can be parsed as if they were
     * `liferay-npm-bundler.config.js` options.
     */
    set argv(argv) {
        const { _configuration } = this;
        if (argv.config) {
            this.loadFrom('.', argv.config);
        }
        if (argv['create-jar']) {
            _configuration['create-jar'] = true;
        }
        if (argv['dump-report']) {
            _configuration['dump-report'] = true;
        }
    }
    _loadConfiguration() {
        const { _configFile } = this;
        const configDir = _configFile.dirname();
        if (fs_1.default.existsSync(configDir.join('.npmbundlerrc').asNative) &&
            Project.WARN_ON_NPMBUNDLERRC) {
            (0, format_1.print)((0, format_1.warn) `There is a {.npmbundlerrc} file in {${configDir.basename()}}: it will be ignored`, (0, format_1.info) `Consider migrating the project to bundler 3.x or removing it if is a leftover`);
        }
        const configFilePath = _configFile.asNative;
        this._configuration = fs_1.default.existsSync(configFilePath)
            ? // eslint-disable-next-line @liferay/no-dynamic-require
                require(configFilePath)
            : {};
    }
    _loadPkgJson() {
        const pkgJsonPath = this.dir.join('package.json').asNative;
        this._pkgJson = fs_1.default.existsSync(pkgJsonPath)
            ? (0, read_json_sync_1.default)(pkgJsonPath)
            : {};
    }
}
exports.default = Project;
Project.WARN_ON_NPMBUNDLERRC = false;
