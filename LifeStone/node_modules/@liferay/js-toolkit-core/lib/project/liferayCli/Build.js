"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2021 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const FilePath_1 = __importDefault(require("../../file/FilePath"));
const persist_1 = __importDefault(require("./persist"));
class Build {
    constructor(project, liferayJson) {
        var _a, _b;
        this._project = project;
        switch (liferayJson.build.type) {
            case 'customElement':
                this.type = 'customElement';
                this.dir = project.dir.join('build');
                this.options = this._toCustomElementBuildOptions(project, (_a = liferayJson.build) === null || _a === void 0 ? void 0 : _a.options);
                break;
            case 'bundler2': {
                const { default: bundler2Project,
                /* eslint-disable-next-line @typescript-eslint/no-var-requires */
                 } = require('liferay-npm-build-tools-common/lib/project');
                this.type = 'bundler2';
                this.dir = new FilePath_1.default(bundler2Project.buildDir.asNative).resolve();
                this.options = this._toBundler2BuildOptions((_b = liferayJson.build) === null || _b === void 0 ? void 0 : _b.options);
                break;
            }
            default:
                throw new Error(`Unknown project build type type: ${liferayJson.build['type']}`);
        }
    }
    storeOption(name, value) {
        let location = 'user-project';
        // Validate options and decide location
        switch (this.type) {
            case 'bundler2':
                switch (name) {
                    case 'minify':
                        break;
                    default:
                        throw new Error(`Unknown option: ${name}`);
                }
                break;
            case 'customElement':
                switch (name) {
                    case 'externals':
                    case 'htmlElementName':
                        location = 'project';
                        break;
                    case 'minify':
                        break;
                    default:
                        throw new Error(`Unknown option: ${name}`);
                }
                break;
            default:
                throw new Error(`Unknown build type: ${this.type}`);
        }
        // Save the option
        this.options[name] = value;
        (0, persist_1.default)(this._project, 'build', `options.${name}`, { location });
    }
    _toCustomElementBuildOptions(project, config) {
        // Infer htmlElementName from source code if needed
        if (!config.htmlElementName) {
            config.htmlElementName = findHtmlElementName(project.mainModuleFile);
        }
        if (!config.portletCategoryName) {
            config.portletCategoryName = 'category.remote-apps';
        }
        const webpackOptions = this._toWebpackBuildOptions(config);
        return {
            externals: webpackOptions.externals,
            htmlElementName: config.htmlElementName,
            minify: webpackOptions.minify,
            portletCategoryName: config.portletCategoryName,
        };
    }
    _toBundler2BuildOptions(_config) {
        return {
            minify: process.env.NODE_ENV !== 'development',
        };
    }
    _toWebpackBuildOptions(config) {
        const options = {
            externals: {},
            minify: process.env.NODE_ENV !== 'development',
        };
        // Turn arrays coming from liferay.json into objects
        if (Array.isArray(config.externals)) {
            options.externals = config.externals.reduce((map, bareIdentifier) => {
                map[bareIdentifier] = bareIdentifier;
                return map;
            }, {});
        }
        else if (config.externals) {
            options.externals = config.externals;
        }
        // Remove externals mapped to null
        options.externals = Object.entries(options.externals).reduce((externals, entry) => {
            if (entry[1] !== null) {
                externals[entry[0]] = entry[1];
            }
            return externals;
        }, {});
        return options;
    }
}
exports.default = Build;
function findHtmlElementName(file) {
    const source = fs_1.default.readFileSync(file.asNative, 'utf8');
    const regex = /customElements.define\(([^(]*)\)/;
    const match = regex.exec(source);
    if (!match) {
        return undefined;
    }
    const args = match[1].trim();
    if (!["'", '"'].includes(args[0])) {
        return undefined;
    }
    const quote = args[0];
    const i = args.indexOf(quote, 1);
    if (i < 0) {
        return undefined;
    }
    return args.substring(1, i);
}
