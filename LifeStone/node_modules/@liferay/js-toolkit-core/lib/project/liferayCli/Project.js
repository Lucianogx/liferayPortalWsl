"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2021 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @liferay/no-dynamic-require */
/* eslint-disable @typescript-eslint/no-explicit-any */
const deepmerge_1 = __importDefault(require("deepmerge"));
const fs_1 = __importDefault(require("fs"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const resolve_1 = __importDefault(require("resolve"));
const FilePath_1 = __importDefault(require("../../file/FilePath"));
const Build_1 = __importDefault(require("./Build"));
const Deploy_1 = __importDefault(require("./Deploy"));
const Dist_1 = __importDefault(require("./Dist"));
const Start_1 = __importDefault(require("./Start"));
class Project {
    constructor(projectPath) {
        this.dir = new FilePath_1.default(projectPath).resolve();
        this.reload();
    }
    reload() {
        const self = this;
        self.isWorkspace = this._isWorkspace();
        self.assetsDir = this.dir.join('assets');
        self.srcDir = this.dir.join('src');
        if (!fs_1.default.existsSync(this.assetsDir.asNative)) {
            self.assetsDir = null;
        }
        self.pkgJson = JSON.parse(fs_1.default.readFileSync(this.dir.join('package.json').asNative, 'utf8'));
        if (this.pkgJson.main) {
            self.mainModuleFile = this.dir.join(new FilePath_1.default(this.pkgJson.main, { posix: true }));
        }
        else {
            self.mainModuleFile = this.srcDir.join('index.js');
        }
        let liferayJson = this._loadLiferayJson();
        if (self.isWorkspace) {
            const clientExtensionYamlPath = this._getClientExtensionYamlPath();
            if (fs_1.default.existsSync(clientExtensionYamlPath)) {
                try {
                    const yamlConfig = js_yaml_1.default.load(fs_1.default.readFileSync(clientExtensionYamlPath, 'utf8'));
                    liferayJson = deepmerge_1.default.all([
                        liferayJson,
                        this._normalizeClientExtensionYaml(yamlConfig),
                    ]);
                }
                catch (error) {
                    if (error.code !== 'ENOENT') {
                        throw error;
                    }
                }
            }
        }
        self.build = new Build_1.default(this, liferayJson);
        self.deploy = new Deploy_1.default(this, liferayJson);
        self.dist = new Dist_1.default(this, liferayJson);
        self.start = new Start_1.default(this, liferayJson);
    }
    /**
     * Requires a module in the context of the project (as opposed to the
     * context of the calling package which would just use a normal `require()`
     * call).
     * @param moduleName
     */
    require(moduleName) {
        return require(this.resolve(moduleName));
    }
    /**
     * Resolves a module in the context of the project (as opposed to the
     * context of the calling package which would just use a normal
     * `require.resolve()` call).
     * @param moduleName
     */
    resolve(moduleName) {
        return resolve_1.default.sync(moduleName, {
            basedir: this.dir.asNative,
        });
    }
    _getAutopreset() {
        const { dependencies = {}, devDependencies = {} } = this.pkgJson;
        const autopresets = Object.keys({
            ...dependencies,
            ...devDependencies,
        }).reduce((autopresets, pkgName) => {
            try {
                const { dependencies } = this.require(`${pkgName}/package.json`);
                if (!dependencies || !dependencies['@liferay/portal-base']) {
                    return autopresets;
                }
                autopresets.push(pkgName);
            }
            catch (error) {
                // ignore
            }
            return autopresets;
        }, []);
        if (autopresets.length > 1) {
            throw new Error('Multiple autopreset dependencies found in project ' +
                `(${autopresets}): please remove the invalid ones.`);
        }
        return autopresets.length ? autopresets[0] : null;
    }
    _isWorkspace() {
        let isWorkspace = false;
        let dir = this.dir.resolve().asNative;
        while (!isWorkspace) {
            try {
                isWorkspace = fs_1.default
                    .readFileSync(path_1.default.join(dir, 'settings.gradle'), 'utf-8')
                    .includes('"com.liferay.gradle.plugins.workspace"');
            }
            catch (error) {
                // ignore
            }
            const newDir = path_1.default.dirname(dir);
            if (newDir === dir) {
                break;
            }
            dir = newDir;
        }
        return isWorkspace;
    }
    _getClientExtensionYamlPath() {
        let dir = this.dir.resolve().asNative;
        while (true) {
            const clientExtensionYamlPath = path_1.default.join(dir, 'client-extension.yaml');
            if (fs_1.default.existsSync(clientExtensionYamlPath)) {
                return clientExtensionYamlPath;
            }
            const newDir = path_1.default.dirname(dir);
            if (newDir === dir ||
                fs_1.default.existsSync(path_1.default.join(dir, 'settings.gradle'))) {
                break;
            }
            dir = newDir;
        }
        return '';
    }
    _loadLiferayJson() {
        const items = [{}];
        const autopreset = this._getAutopreset();
        if (autopreset) {
            try {
                items.push(this.require(`${autopreset}/liferay.json`));
            }
            catch (error) {
                // ignore
            }
        }
        [
            path_1.default.join(os_1.default.homedir(), '.liferay.json'),
            this.dir.join('.liferay.json').asNative,
            this.dir.join('liferay.json').asNative,
        ].forEach((liferayJsonPath) => {
            try {
                items.push(JSON.parse(fs_1.default.readFileSync(liferayJsonPath, 'utf8')));
            }
            catch (error) {
                if (error.code !== 'ENOENT') {
                    throw error;
                }
            }
        });
        const liferayJson = deepmerge_1.default.all(items.map((item) => this._normalizeLiferayJson(item)));
        // Default project type is 'bundler2'
        liferayJson.build = liferayJson.build || {
            options: {},
            type: 'bundler2',
        };
        liferayJson.build.type = liferayJson.build.type || 'bundler2';
        return liferayJson;
    }
    _normalizeClientExtensionYaml(yamlConfig) {
        const { type, ...otherConfig } = yamlConfig[this.pkgJson.name];
        return {
            build: {
                options: otherConfig,
                type,
            },
        };
    }
    _normalizeLiferayJson(liferayJson) {
        // Normalize externals if they exist
        var _a;
        const options = (_a = liferayJson.build) === null || _a === void 0 ? void 0 : _a.options;
        if (options && options.externals) {
            if (Array.isArray(options.externals)) {
                options.externals = options.externals.reduce((map, bareIdentifier) => {
                    map[bareIdentifier] = bareIdentifier;
                    return map;
                }, {});
            }
        }
        return liferayJson;
    }
}
exports.default = Project;
