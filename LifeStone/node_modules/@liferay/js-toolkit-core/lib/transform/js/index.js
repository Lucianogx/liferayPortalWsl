"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSourceFile = exports.transformSource = exports.replace = void 0;
const escodegen = __importStar(require("escodegen"));
const estraverse = __importStar(require("estraverse"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const source_map_1 = require("source-map");
const parse_1 = require("./parse");
async function replace(source, visitor) {
    // TODO: clone source.ast to avoid modifying source?
    const ast = source.ast || (0, parse_1.parse)(source.code);
    estraverse.replace(ast, visitor);
    const file = source.map ? source.map.file : '<unknown>';
    const transformed = generate(ast, source.code, file);
    return {
        ast,
        code: transformed.code,
        map: await mergeMaps(source.map, transformed.map),
    };
}
exports.replace = replace;
async function transformSource(source, ...transforms) {
    source.ast = source.ast || (0, parse_1.parse)(source.code);
    return await transforms.reduce(async (sourcePromise, transform) => transform(await sourcePromise), Promise.resolve(source));
}
exports.transformSource = transformSource;
/**
 * Transform a JavaScript file in place
 *
 * @param fromFile the file to transform
 * @param toFile the destination file
 * @param transforms the transform functions to apply
 */
async function transformSourceFile(fromFile, toFile, ...transforms) {
    let source = readSource(fromFile);
    source = await transformSource(source, ...transforms);
    writeSource(source, toFile);
}
exports.transformSourceFile = transformSourceFile;
function generate(ast, code, file) {
    if (code === undefined) {
        throw new Error('Code is undefined: sourcemap cannot be generated');
    }
    if (file === undefined) {
        throw new Error('File is undefined: sourcemap cannot be generated');
    }
    const generated = escodegen.generate(ast, {
        sourceContent: code,
        sourceMap: file,
        sourceMapWithCode: true,
    });
    return {
        code: generated.code,
        map: {
            ...JSON.parse(generated.map.toString()),
            file,
        },
    };
}
/**
 * Merge old source map and new source map and return merged.
 *
 * @param old source map object
 * @param newmap new source map object
 * @return merged source map object
 */
async function mergeMaps(oldMap, newMap) {
    if (oldMap === undefined) {
        return newMap;
    }
    const mergedMapGenerator = new source_map_1.SourceMapGenerator();
    /* eslint-disable @typescript-eslint/await-thenable */
    const oldMapConsumer = await new source_map_1.SourceMapConsumer(oldMap);
    const newMapConsumer = await new source_map_1.SourceMapConsumer(newMap);
    /* eslint-enable @typescript-eslint/await-thenable */
    newMapConsumer.eachMapping((mapping) => {
        // Note that there is no `originalLine` when the node does not come from
        // the original code
        if (!mapping.originalLine) {
            return;
        }
        const origPosInOldMap = oldMapConsumer.originalPositionFor({
            column: mapping.originalColumn,
            line: mapping.originalLine,
        });
        if (origPosInOldMap.source === null ||
            origPosInOldMap.source === undefined) {
            return;
        }
        mergedMapGenerator.addMapping({
            generated: {
                column: mapping.generatedColumn,
                line: mapping.generatedLine,
            },
            name: origPosInOldMap.name,
            original: {
                column: origPosInOldMap.column,
                line: origPosInOldMap.line,
            },
            source: origPosInOldMap.source,
        });
    });
    oldMapConsumer.destroy();
    newMapConsumer.destroy();
    const map = JSON.parse(mergedMapGenerator.toString());
    // Set the destination file of the map
    map.file = newMap.file;
    // Add original source contents
    map.sources = [...oldMap.sources];
    map.sourcesContent = [...oldMap.sourcesContent];
    return map;
}
function readSource(file) {
    const source = {
        code: fs_extra_1.default.readFileSync(file.asNative).toString(),
    };
    // TODO: read source map from file annotation instead of guessing
    // the file name
    try {
        source.map = fs_extra_1.default.readJsonSync(`${file.asNative}.map`);
    }
    catch (error) {
        // ignore
    }
    return source;
}
function writeSource(source, file) {
    fs_extra_1.default.ensureDirSync(file.dirname().asNative);
    fs_extra_1.default.writeFileSync(file.asNative, source.code + '\n' + `//# sourceMappingURL=${file.basename()}.map`);
    fs_extra_1.default.writeFileSync(`${file.asNative}.map`, JSON.stringify({
        ...source.map,
        file: file.asPosix,
    }));
}
