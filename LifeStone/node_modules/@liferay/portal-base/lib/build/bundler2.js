"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2021 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel = __importStar(require("@babel/core"));
const preset_env_1 = __importDefault(require("@babel/preset-env"));
const preset_react_1 = __importDefault(require("@babel/preset-react"));
const js_toolkit_core_1 = require("@liferay/js-toolkit-core");
const babel_preset_minify_1 = __importDefault(require("babel-preset-minify"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const abort_1 = __importDefault(require("../util/abort"));
const findFiles_1 = __importDefault(require("../util/findFiles"));
const runSass_1 = __importDefault(require("../util/runSass"));
const spawn_1 = __importDefault(require("../util/spawn"));
const { info, print } = js_toolkit_core_1.format;
async function bundler2(project) {
    fs_1.default.mkdirSync(project.build.dir.asNative, { recursive: true });
    copyAssets(project);
    (0, runSass_1.default)(project);
    runCompiler(project);
    runBundler();
}
exports.default = bundler2;
function copyAssets(project) {
    const assetFiles = (0, findFiles_1.default)(project.srcDir, (dirent) => {
        const lowerCaseName = dirent.name.toLowerCase();
        return (!lowerCaseName.endsWith('.js') && !lowerCaseName.endsWith('.scss'));
    });
    print(info `Copying ${assetFiles.length} {assets}...`);
    assetFiles.forEach((assetFile) => {
        const srcDirRelAssetFile = project.srcDir.relative(assetFile);
        const outFile = project.build.dir.join(srcDirRelAssetFile);
        try {
            fs_1.default.mkdirSync(outFile.dirname().asNative, { recursive: true });
            fs_1.default.copyFileSync(assetFile.asNative, outFile.asNative);
        }
        catch (error) {
            (0, abort_1.default)(error);
        }
    });
}
function runBabel(project) {
    const options = project.build.options;
    const jsFiles = (0, findFiles_1.default)(project.srcDir, (dirent) => dirent.name.toLowerCase().endsWith('.js'));
    const presets = [preset_env_1.default, preset_react_1.default];
    if (options.minify) {
        presets.push(babel_preset_minify_1.default);
    }
    print(info `Running {babel} on ${jsFiles.length} files...`);
    jsFiles.forEach((jsFile) => {
        const srcDirRelJsFile = project.srcDir.relative(jsFile);
        try {
            const { code, map } = babel.transformSync(fs_1.default.readFileSync(jsFile.asNative, 'utf8'), {
                filename: jsFile.asNative,
                presets,
                sourceMaps: true,
            });
            fs_1.default.mkdirSync(project.build.dir.join(srcDirRelJsFile).dirname().asNative, {
                recursive: true,
            });
            fs_1.default.writeFileSync(project.build.dir.join(srcDirRelJsFile).asNative, `${code}\n//# sourceMappingURL=${srcDirRelJsFile.basename()}.map`, 'utf8');
            fs_1.default.writeFileSync(project.build.dir.join(`${srcDirRelJsFile}.map`).asNative, JSON.stringify(map), 'utf8');
        }
        catch (babelError) {
            (0, abort_1.default)(babelError);
        }
    });
}
function runCompiler(project) {
    const dependencies = project.pkgJson.dependencies || {};
    if (dependencies['@angular/core']) {
        runTsc();
    }
    else {
        runBabel(project);
    }
}
function runBundler() {
    const bundlerPkgJsonPath = require.resolve('liferay-npm-bundler/package.json');
    const bundlerDir = path_1.default.dirname(bundlerPkgJsonPath);
    /* eslint-disable-next-line */
    const bundlerPkgJson = require(bundlerPkgJsonPath);
    const bundlerPath = path_1.default.resolve(bundlerDir, bundlerPkgJson.bin['liferay-npm-bundler']);
    print(info `Running {liferay-npm-bundler}...`);
    (0, spawn_1.default)('node', [bundlerPath]);
}
function runTsc() {
    print(info `Running {tsc} compiler...`);
    (0, spawn_1.default)('npx', ['tsc']);
}
