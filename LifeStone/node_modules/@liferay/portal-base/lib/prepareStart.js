"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2021 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const js_toolkit_core_1 = require("@liferay/js-toolkit-core");
const format_1 = require("@liferay/js-toolkit-core/lib/format");
const fs_1 = __importDefault(require("fs"));
const jszip_1 = __importDefault(require("jszip"));
const readline_1 = require("readline");
const configureDeploy_1 = __importDefault(require("./configureDeploy"));
const createManifest_1 = __importDefault(require("./util/createManifest"));
const startableProjectTypes_1 = require("./util/startableProjectTypes");
const { fail, info, print } = js_toolkit_core_1.format;
async function prepareStart() {
    const project = new js_toolkit_core_1.Project('.');
    (0, startableProjectTypes_1.ensureProjectIsStartable)(project);
    const zipFile = await deployZip(project);
    process.on('exit', () => {
        print((0, format_1.warn) `
Undeployed live development Remote App from Liferay.`);
        print(info `
Run 'yarn deploy' if you want to make your Remote App available in your Liferay
server again by deploying a non-live version of it.`);
        fs_1.default.rmSync(zipFile.asNative);
    });
}
exports.default = prepareStart;
async function checkForOldZipFile(zipFile) {
    if (!fs_1.default.existsSync(zipFile.asNative)) {
        return;
    }
    print((0, format_1.warn) `
There is an older version of this project in your Liferay server.`);
    print(info `
Continuing with the 'start' command will redeploy the project and the older
version will be overwritten.`);
    print((0, format_1.question) `
Are you sure you want to continue (y/N)?`);
    const lines = (0, readline_1.createInterface)({
        input: process.stdin,
    });
    for await (const line of lines) {
        if (line.toLowerCase() === 'y') {
            break;
        }
        print(fail `Deployment aborted by user`);
        process.exit(2);
    }
}
async function deployZip(project) {
    if (!project.deploy.dir) {
        print('', (0, format_1.warn) `There's no deploy configuration for the project yet`, '', info `The Deploy configuration wizard will be run before doing anything.`);
        await (0, configureDeploy_1.default)();
        project.reload();
    }
    const deployDir = project.deploy.dir;
    if (!deployDir) {
        print(fail `No path to Liferay installation given: cannot deploy`);
        process.exit(1);
    }
    const zipFile = project.deploy.dir.join(`${project.pkgJson.name}.zip`);
    await checkForOldZipFile(zipFile);
    const manifest = (0, createManifest_1.default)(project);
    const configurationPid = 'com.liferay.client.extension.type.configuration.CETConfiguration~' +
        project.pkgJson.name;
    const clientExtensionConfigJson = {
        [configurationPid]: {
            baseURL: `http://localhost:${project.start.port}`,
            description: project.pkgJson.description || '',
            name: `${project.pkgJson.name} (live development)`,
            sourceCodeURL: '',
            type: 'customElement',
            typeSettings: [
                `cssURLs=${manifest.cssURLs.join('\n')}`,
                `htmlElementName=${manifest.htmlElementName}`,
                'instanceable=true',
                `portletCategoryName=${manifest.portletCategoryName}`,
                `urls=${manifest.urls.join('\n')}`,
                `useESM=${manifest.useESM}`,
            ],
        },
    };
    const zip = new jszip_1.default();
    zip.file(`${project.pkgJson.name}.client-extension-config.json`, JSON.stringify(clientExtensionConfigJson, null, '\t'));
    const buffer = await zip.generateAsync({
        compression: 'DEFLATE',
        compressionOptions: {
            level: 6,
        },
        type: 'nodebuffer',
    });
    fs_1.default.writeFileSync(zipFile.asNative, buffer);
    return zipFile;
}
