"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2021 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const js_toolkit_core_1 = require("@liferay/js-toolkit-core");
const webpack_1 = __importStar(require("webpack"));
const { debug, fail, info, print, text } = js_toolkit_core_1.format;
async function runWebpack(project, configuration) {
    print(info `Running {webpack}...`);
    const stats = await new Promise((resolve) => {
        const compiler = (0, webpack_1.default)(configuration);
        compiler.hooks.done.tap('portal-base', (stats) => {
            resolve(stats);
        });
        compiler.run(undefined);
    });
    print(debug `Created assets:`);
    Object.entries(stats.compilation.assets).forEach(([filePath, sizeSource]) => {
        let size = sizeSource.size();
        let unit = 'B';
        if (size > 1024) {
            size = Math.floor(sizeSource.size() / 1024);
            unit = 'KiB';
        }
        if (size > 1024) {
            size =
                Math.floor((10 * sizeSource.size()) / (1024 * 1024)) / 10;
            unit = 'MiB';
        }
        print(text `    * {${filePath}}: ${size} ${unit}`);
    });
    let { externals } = configuration;
    if (externals) {
        print(debug `External modules:`);
        const usedExternals = Array.from(stats.compilation.modules)
            .filter((module) => module instanceof webpack_1.ExternalModule)
            .map((module) => module.request);
        externals = Object.entries(externals).reduce((externals, [bareIdentifier, url]) => {
            if (usedExternals.includes(bareIdentifier) ||
                usedExternals.includes(url)) {
                externals[bareIdentifier] = url;
            }
            return externals;
        }, {});
        if (!Object.keys(externals).length) {
            print(text `    (none)`);
        }
        else {
            Object.entries(externals).forEach(([from, to]) => {
                print(text `    * {${from}} (mapped to {${to}})`);
            });
        }
    }
    print(debug `Bundled modules per package:`);
    const summary = Array.from(stats.compilation.modules)
        .map((mod) => mod['resource'])
        .filter((filePath) => filePath)
        .map((filePath) => project.dir.relative(filePath).asPosix)
        .filter((filePath) => filePath.startsWith('node_modules/'))
        .map((filePath) => filePath.substring(13))
        .reduce((summary, moduleName) => {
        const parts = (0, js_toolkit_core_1.splitModuleName)(moduleName);
        const pkgName = (0, js_toolkit_core_1.joinModuleName)(parts.scope, parts.pkgName, '');
        summary[pkgName] = summary[pkgName] || 0;
        summary[pkgName]++;
        return summary;
    }, {});
    Object.keys(summary)
        .sort()
        .forEach((pkgName) => {
        print(text `    * {${pkgName}}: ${summary[pkgName]}`);
    });
    if (stats.hasErrors()) {
        abortWithErrors(stats);
    }
    return stats;
}
exports.default = runWebpack;
function abortWithErrors(stats) {
    const { errors } = stats.compilation;
    print(fail `Build failed (webpack build finished with errors):`);
    errors.forEach((error) => {
        console.error(`${error.message}`);
    });
    process.exit(1);
}
