"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2017 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const file_path_1 = __importDefault(require("liferay-npm-build-tools-common/lib/file-path"));
const ns = __importStar(require("liferay-npm-build-tools-common/lib/namespace"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
/**
 * @param {object} context loader's context
 */
function default_1(context, { emitCssFile = true, extension, namespaceDependencies = true, pathModule = '/o', }) {
    const { filePath, log } = context;
    const href = getHref(filePath, extension, pathModule, namespaceDependencies);
    // Note that Liferay.ThemeDisplay.getPathContext() when called at runtime
    // returns both pathProxy and the context path of the portal's webapp.
    context.extraArtifacts[`${filePath}.js.wrap-modules-amd.template`] = `
var link = document.createElement("link");
link.setAttribute("rel", "stylesheet");
link.setAttribute("type", "text/css");
link.setAttribute("href", Liferay.ThemeDisplay.getPathContext() + "${href}");

function defineModule() {
	__WRAPPED_MODULE__	
}

link.onload = defineModule;

link.onerror = function() {
	console.warn('Unable to load ${href}. However, its .js module will still be defined to avoid breaking execution flow (expect some visual degradation).');

	defineModule();
}

document.querySelector("head").appendChild(link);
`;
    context.extraArtifacts[`${filePath}.js`] = `
module.exports = link;
`;
    if (!emitCssFile) {
        context.content = undefined;
    }
    log.info('css-loader', `Generated .js module to inject '${href}'`);
}
exports.default = default_1;
function getHref(filePath, extension, pathModule, namespaceDependencies) {
    let webContextPath;
    if (project_1.default.jar.supported) {
        webContextPath = project_1.default.jar.webContextPath;
    }
    else {
        const bnd = fs_1.default
            .readFileSync(project_1.default.dir.join('bnd.bnd').asNative)
            .toString();
        const lines = bnd.split('\n');
        const webContextPathLine = lines.find((line) => line.startsWith('Web-ContextPath:'));
        if (webContextPathLine === undefined) {
            throw new Error('Cannot determine web context path for the project: ' +
                'either specify it in .npmbundlerrc or bnd.bnd');
        }
        webContextPath = webContextPathLine.substring(16).trim();
    }
    if (filePath.indexOf(`node_modules${path_1.default.sep}`) !== -1) {
        const pathParts = filePath.split(path_1.default.sep);
        const projectNameIndex = lastIndexOf(pathParts, 'node_modules') + 1;
        let projectName = pathParts[projectNameIndex];
        let projectFilePathParts = pathParts.slice(projectNameIndex + 1);
        if (projectName.startsWith('@')) {
            projectName = path_1.default.join(projectName, pathParts[projectNameIndex + 1]);
            projectFilePathParts = projectFilePathParts.slice(1);
        }
        const { version } = read_json_sync_1.default(path_1.default.join(...pathParts.slice(0, projectNameIndex), projectName, 'package.json'));
        let namespacedProjectName = projectName;
        if (namespaceDependencies) {
            namespacedProjectName = ns.addNamespace(projectName, project_1.default.pkgJson);
        }
        namespacedProjectName += `@${version}`;
        filePath = path_1.default.join('node_modules', namespacedProjectName, ...projectFilePathParts);
    }
    else {
        // If file is inside a source folder, strip the folder name
        for (let sourcePath of project_1.default.sources.map((source) => source.asNative)) {
            // Remove `./` from sourcePath so that it matches the filePath correctly
            sourcePath = sourcePath.substring(2);
            if (filePath.startsWith(sourcePath)) {
                filePath = filePath.substring(sourcePath.length + 1);
                break;
            }
        }
    }
    if (extension !== undefined) {
        const extname = path_1.default.extname(filePath);
        if (!extname) {
            filePath = `${filePath}.${extension}`;
        }
        else {
            filePath = filePath.replace(new RegExp(`\\${extname}$`), `${extension}`);
        }
    }
    filePath = new file_path_1.default(filePath).asPosix;
    return `${pathModule}${webContextPath}/${filePath}`;
}
function lastIndexOf(array, item) {
    for (let i = array.length - 1; i >= 0; i--) {
        if (array[i] === item) {
            return i;
        }
    }
    return -1;
}
